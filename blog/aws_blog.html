<!DOCTYPE html>
<html>
    
    <head>
        <title>Stocksy's AWS Challenge Blog</title>

        <style>
            .myDiv {
                border: 5px outset red;
                text-align: center;
                font-family: Verdana, Geneva, Tahoma, sans-serif;
            }
            body {
                background-color: rgb(134, 160, 158);
            }
            h1 {
                color: black;
                text-align: center;
            }
            h3 {
                color: white;
                text-align: left;
                font-family: Verdana, Geneva, Tahoma, sans-serif;
            }
            h4 {
                color: black;
                text-align: center;
                font-family: Verdana, Geneva, Tahoma, sans-serif;
            }
            p {
                font-family: Verdana, Geneva, Tahoma, sans-serif;
                font-size: 20px;
            }
            ol {
                font-family: Verdana, Geneva, Tahoma, sans-serif;
                font-size: 16px;
            }
            ul {
                font-family: Verdana, Geneva, Tahoma, sans-serif;
                font-size: 16px;
            }
        </style>

    </head>
    
    <body>

        <h1>
            Stocksy's AWS Cloud Resume Challenge Blog
        </h1>

        <h3>
            Requirements
        </h3>

        <p>
            Per the requirements given in <a href="https://cloudresumechallenge.dev/docs/the-challenge/aws/" target="_blank">The Cloud Resume Challenge - AWS</a>, the stockscloud.co.uk website was built with several architecture principles in mind based on my interpretation of the design spec while considering the <a href="https://aws.amazon.com/architecture/well-architected/?wa-lens-whitepapers.sort-by=item.additionalFields.sortDate&wa-lens-whitepapers.sort-order=desc&wa-guidance-whitepapers.sort-by=item.additionalFields.sortDate&wa-guidance-whitepapers.sort-order=desc" target="_blank">Six Pillars of the AWS Well-Architected Framework</a>.
            I used the MOSCOW method (MUST, SHOULD, COULD, WONT) as described below. Although all requirements might be judged initially to be MUST, where appropriate I used tooling which allows for some improvements versus the original design spec.

            <ol type="1">
                <li>MUST implement Security best practices: I've used principle of least privilege for all IAM users and policies. Data is encrypted in transit (HTTPS with TLSv1.3) and data is encrypted at rest (table objects using DynamoDB-owned KMS key, bucket objects using SSE-S3). I've added a bucket policy which only allows the CloudFront Distribution to access the S3 origin via CloudFront Origin Access Control.</li>
                <li>MUST utilise Cost Optimization and Performance Efficiency: I've used a Serverless architecture; on-demand DynamoDB table (a pay-per-use payment model), an API Gateway fronting a Lambda function for the hit counter instead of long-running EC2 instances or running a Container platform. Lambda is always free up to 1 million invocations per month :)</li>
                <li>MUST apply Operational Excellence: Use automation and event-driven architectures: I've made both the website's backend and frontend deployable through GitHub Actions upon git push to the Main branch. Monitoring of failed GitHub pipelines and CloudWatch monitoring is included out-of-the-box for most AWS services, further improving operational responsiveness.</li>
                <li>MUST perform Reliably: By using AWS-managed services such as CloudFront, S3, DynamoDB, the services utilised are highly available within a single region. This provides more than enough reliability for my website use case.</li>
                <li>MUST consider Sustainability: Employing a Serverless architecture ensures that workloads only run for as long as necessary. Using CDK templates and CloudFormation stacks means that infrastructure is declarative and can be quickly disposed of when no longer needed.</li>
                <li>SHOULD use CI/CD, HTML, CSS and a JavaScript website hit counter for the frontend and store backend code in source control: I hand-crafted much of the HTML but found that I couldn't write a JavaScript hitcounter function. Here, I leveraged <a href=https://claude.ai/" target="_blank">Claude AI</a> to assist me with a JavaScript function which interfaces with a REST API Gateway endpoint. The API invokes a Python 3.9 Lambda function to increment the page hit count. The hit count is persisted in a DynamoDB table. CSS is used to style the body elements.</li>
                <li>SHOULD use an API, Python (including Tests), a Database, again with CI/CD for the backend: I utilised GitHub Actions, enabling all of the backend components to be created as a CloudFormation stack using "cdk deploy" within the GitHub Actions workflow. The CDK template was written in TypeScript; coding was again ably assisted by Claude AI who wrote much of the template.</li>
                <li>COULD use SAM (Serverless Application Model) templates to define the backend infrastructure and store backend code in source control: Here I deviated from the design spec by opting to use CDK (Cloud Development Kit), a well-supported framework for defining infrastructure-as-code in a number of popular languages. I opted for TypeScript due to its support by AWS and usage within my own business environment, allowing me to upskill in CDK. I covered the CI/CD requirements by implementing GitHub Actions workflows for both the frontend (website) and backend (infrastructure) repos and set the workflows to run upon a git push to the Main branch. The repos themselves are private.</li>
                <li>COULD write a Blog post about my experience. I did!</li>
            </ol>

        </p>

        <h3>
            Architecture
        </h3>

        <p>
            <embed
                src="../assets/website_architecture.pdf"
                type="application/pdf"
                width="100%"
                height="1000"
                title="Website Architecture PDF"
                />
        </p>

        <h3>
            Future Improvements
        </h3>

        <p>
            While Security best practices have been followed reasonably well, the implementation of this website includes some IAM issues which can be addressed. <u>Encrypted secrets</u> used by GitHub Actions are placed into environment variables, working in concert with least-privileged AWS users/policies to perform tasks such as updating the CloudFormation stack, Website file PUT requests to S3 and CloudFront cache invalidation. These use long-lived credentials (access keys) which although encrypted does not apply latest security best practices and for this reason most companies have moved away from using them.
            AWS highly recommend implementing IAM Roles to issue STS (Security Token Service) calls such as <i>sts:AssumeRole</i> and <i>sts:AssumeRoleWithWebIdentity</i>. This provides temporary access credentials by issuing an Access Key ID, a Secret Access Key and a Security Token. The timebound nature of access tokens makes them by definition more secure than using long-lived credentials. I aim to make using Roles and integrating them into GitHib Actions the main future enhancement for the site.
        </p>

        <h3>
            Final Thoughts
        </h3>

        <p>
            You might be thinking "It's a static website, you could have just hosted it in S3!" Yes I <i>could</i>, however there is justification for taking my approach:

            <ul>
                <li>Principally, I would have failed to meet the design spec of the Cloud Resume Challenge; reason enough to steer away from the simplest possible cloud hosting solution.</li>
                <li>The site is HTTPS because it has a Route 53 hosted zone including an ACM (AWS Certificate Manager) certificate issued by the Amazon CA. This is much more secure than a plain HTTP site hosted from an S3 bucket (or anywhere which does not natively offer HTPPS).</li>
                <li>The inclusion of a CloudFront Distribution means the site takes advantage of edge-optimisation and regional edge caches for serving the site pages and assets. This makes the site highly available to a global userbase with decreased latency & jitter versus accessing directly from an S3 endpoint. As mentioned in the Requirements section, <b>only</b> the Distribution can access the S3 origin directly, further strengthening the security posture of the site. Due to the globally-distributed design of the CloudFront CDN and its edge locations, it offers some mitigation beenfits against DDoS attacks, although WAF and Shield Advanced should be considered when running production workloads.</li>
                <li>In the S3 bucket properties, AWS recommend using <a href="https://aws.amazon.com/amplify/faqs/?trk=bde46bbc-b618-48e1-b86a-1dd4c35b930f&sc_channel=ps&ef_id=EAIaIQobChMIyuLR26TLjQMV15VQBh3RlxEGEAAYASABEgJ19vD_BwE:G:s&s_kwcid=AL!4422!3!647301968149!e!!g!!aws%20amplify!19621293721!146139123512&gad_campaignid=19621293721&gbraid=0AAAAADjHtp-McekRy0of67TMEVkfAd3-w&gclid=EAIaIQobChMIyuLR26TLjQMV15VQBh3RlxEGEAAYASABEgJ19vD_BwE" target="_blank">Amplify</a> over S3 web hosting.</li>
            </ul>
        </p>

        <p>
            Thanks for reading!
        </p>

        <p>
            <a href="../">Home</a>
        </p>

        <!-- Hit counter, written by Claude AI -->
        <div id="hitCounter">Hit Counter: Loading...</div>
        
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                try {
                    const counter = document.getElementById('hitCounter');
                    if (!counter) return; // Exit if element not found
                    
                    // Get the page path to use as a unique identifier
                    const pagePath = window.location.pathname;

                    // API_ENDPOINT env var will be replaced during build time
                    const apiEndpoint = '%%API_ENDPOINT%%/incrementCounter';

                    // Call the API Gateway endpoint to increment the counter
                    fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ pagePath: pagePath })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Update the counter with the value from the DB
                        counter.textContent = 'Hit Counter: ' + data.count;
                    })
                    .catch(error => {
                        console.error('Error updating hit counter:', error);
                        counter.textContent = 'Hit Counter: Error';
                    });
                } catch (error) {
                    console.log('Hit counter error:', error);
                }
            });
        </script>

    </body>

</html>
