<!DOCTYPE html>
<html>
    
    <head>
        <title>Stocksy's AWS Challenge Blog</title>

        <style>
            .myDiv {
                border: 5px outset red;
                text-align: center;
                font-family: Verdana, Geneva, Tahoma, sans-serif;
            }
            body {
                background-color: rgb(134, 160, 158);
            }
            h1 {
                color: black;
                text-align: center;
            }
            h3 {
                color: white;
                text-align: left;
                font-family: Verdana, Geneva, Tahoma, sans-serif;
            }
            h4 {
                color: black;
                text-align: center;
                font-family: Verdana, Geneva, Tahoma, sans-serif;
            }
            p {
                font-family: Verdana, Geneva, Tahoma, sans-serif;
                font-size: 20px;
            }
            ul {
                font-family: Verdana, Geneva, Tahoma, sans-serif;
                font-size: 16px;
            }
        </style>

    </head>
    
    <body>

        <h1>
            Stocksy's AWS Cloud Resume Challenge Blog
        </h1>

        <h3>
            Requirements
        </h3>

        <p>
            Per the requirements given in <a href="https://cloudresumechallenge.dev/docs/the-challenge/aws/" target="_blank">The Cloud Resume Challenge - AWS</a>, the website was built with several architecture principles in mind, based on my interpretation of the design spec.
            I used the MOSCOW method (MUST, SHOULD, COULD, WONT) - as described below. Although all requirements might be judged initially as MUST, I considered the <a href="https://aws.amazon.com/architecture/well-architected/?wa-lens-whitepapers.sort-by=item.additionalFields.sortDate&wa-lens-whitepapers.sort-order=desc&wa-guidance-whitepapers.sort-by=item.additionalFields.sortDate&wa-guidance-whitepapers.sort-order=desc" target="_blank">Six Pillars of the AWS Well-Architected Framework</a> and where appropriate used tooling which in my experience can make some implementation improvements over the original design spec.

            <ol type="1">
                <li>MUST implement Security best practices: I've used principle of least privilege for all IAM users and policies. Data is encrypted in transit (HTTPS with TLSv1.3) and data is encrypted at rest (table objects using DynamoDB-owned KMS key, bucket objects using SSE-S3). I've added a bucket policy which only allows the CloudFront Distribution to access the S3 origin via CloudFront Origin Access Control.</li>
                <li>MUST utilise Cost Optimization and Performance Efficiency: I've used a Serverless architecture; on-demand DynamoDB table (a pay-per-use payment model), an API Gateway fronting a Lambda function for the hit counter instead of long-running EC2 instances or running a Container platform. Lambda is always free up to 1 million invocations per month :)</li>
                <li>MUST apply Operational Excellence: Use automation and event-driven architectures: I've made both the website's backend and frontend deployable through GitHub Actions upon git push to the Main branch. Monitoring of failed GitHub pipelines and CloudWatch monitoring is included out-of-the-box for most AWS services, further improving operational responsiveness.</li>
                <li>MUST perform Reliably: By using AWS-managed services such as CloudFront, S3, DynamoDB, the services utilised are highly available within a single region. This provides more than enough reliability for my website use case.</li>
                <li>MUST consider Sustainability: Employing a Serverless architecture ensures workloads do not runn for longer than necessary and using CDK/CloudFormation templates ensures that infrastructure can be disposed of quickly when no longer required.</li>
                <li>SHOULD use CI/CD, HTML, CSS and a JavaScript website hit counter on the frontend: I hand-crafted much of the HTML but found that I couldn't write a JavaScript hitcounter function. Here, I leveraged <a href=https://claude.ai/" target="_blank">Claude AI</a> to assist me with a JavaScript function which interfaces with a REST API Gateway endpoint. The API invokes a Python 3.9 Lambda function to increment the page hit count. The hit count is persisted in a DynamoDB table. More on the backend components below.</li>
                <li>SHOULD use an API, Python (including Tests), a Database, again with CI/CD for the backend: I utilised GitHub Actions, enabling all of the backend components to be created as a CloudFormation Stack using "cdk deploy" within the GitHub Actions workflow. The CDK template was written in TypeScript; coding was again ably assisted by Claude AI.</li>
                <li>COULD use SAM (Serverless Application Model) templates to define the backend infrrastrucure and store all code in source control: Here I deviated from the design spec by opting to use CDK (Cloud Development Kit), a well-supported framework for defining infrastructure-as-code in a number of popular languages. I opted for TypeScript due to its support by AWS and usage within my own business environment, allowing me to upskill in CDK. I covered the CI/CD requirements by implementing GitHub Actions workflows for both the frontend (website) and backend (infrastructure) repos and set the workflows to run upon a git push to the Main branch. The repos themselves are private.</li>
                <li>COULD write a Blog post about my experience. I did!</li>
            </ol>

        </p>

        <h3>
            Architecture
        </h3>

        <p>
            <embed
                src="../assets/website_architecture.pdf"
                type="application/pdf"
                width="100%"
                height="1000"
                title="Website Architecture PDF"
                />
        </p>

        <h3>
            Future Improvements
        </h3>

        <p>
            While Security best practices have been followed reasonably well, the implemenation of this website is not free of issues. <u>Encrypted secrets</u> used by GitHub Actions are placed into environment variables, working in concert with least-privileged AWS users to perform tasks such as updating the CloudFormation Stack, Website file PUT requests into S3 buckets and invalidating the CloudFront Distribution cache. These are long-lived credentials (access keys) which although encrypted, does not follow security best practices and most companies have moved away from using them.
            AWS highly recommend implementing IAM Roles to issue STS (Security Token Service) calls such as <i>sts:AssumeRole</i> and <i>sts:AssumeRoleWithWebIdenity</i>. These provide short-lived access credentials based on an Access Key ID, a Secret Access Key and a Security Token. The timebound nature of these access tokens makes them by definition more secure than long-lived creds. This is a future enhacement I would like to make to the site.
        </p>

        <h3>
            Final Thoughts
        </h3>

        <p>
            You might be thinking "It's a static website; you could have just hosted it in S3!" Yes I <i>could</i>, however here is some justification for my approach:

            <ul>
                <li>Principally, I would have failed to meet the design spec of the Cloud Resume Challenge - A great reasonin itself to steer away from the simplest possible hosting solution.</li>
                <li>In the S3 bucket properties, AWS recommend using <a href="https://aws.amazon.com/amplify/faqs/?trk=bde46bbc-b618-48e1-b86a-1dd4c35b930f&sc_channel=ps&ef_id=EAIaIQobChMIyuLR26TLjQMV15VQBh3RlxEGEAAYASABEgJ19vD_BwE:G:s&s_kwcid=AL!4422!3!647301968149!e!!g!!aws%20amplify!19621293721!146139123512&gad_campaignid=19621293721&gbraid=0AAAAADjHtp-McekRy0of67TMEVkfAd3-w&gclid=EAIaIQobChMIyuLR26TLjQMV15VQBh3RlxEGEAAYASABEgJ19vD_BwE" target="_blank">Amplify</a> over S3 Static Web Hosting.</li>
                <li>I added HTTPS by using a Route 53 hosted zone including an ACM certificate issued by Amazon's CA. This is more secure than a plain HTTP site hosted from an S3 bucket.</li>
                <li>The inclusion of a CloudFront Distribution means the site takes advantage of edge-optimisation and regional edge caches for serving the site and its assets. This makes stockscloud.co.uk available to a global userbase with decreased latency/jitter over accessing the site using S3. As mentioned in the requirements, <b>only</b> the Distribution can access the S3 origin, further strengthening the security posture of the site.</li>
            </ul>
        </p>

        <p>
            Thanks for reading!
        </p>

        <p>
            <a href="../">Home</a>
        </p>

        <!-- Hit counter, written by Claude AI -->
        <div id="hitCounter">Hit Counter: Loading...</div>
        
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                try {
                    const counter = document.getElementById('hitCounter');
                    if (!counter) return; // Exit if element not found
                    
                    // Get the page path to use as a unique identifier
                    const pagePath = window.location.pathname;

                    // API_ENDPOINT env var will be replaced during build time
                    const apiEndpoint = '%%API_ENDPOINT%%/incrementCounter';

                    // Call the API Gateway endpoint to increment the counter
                    fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ pagePath: pagePath })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Update the counter with the value from the DB
                        counter.textContent = 'Hit Counter: ' + data.count;
                    })
                    .catch(error => {
                        console.error('Error updating hit counter:', error);
                        counter.textContent = 'Hit Counter: Error';
                    });
                } catch (error) {
                    console.log('Hit counter error:', error);
                }
            });
        </script>

    </body>

</html>
