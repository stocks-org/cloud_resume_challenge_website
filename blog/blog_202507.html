<!DOCTYPE html>
<html>
    <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    * {
    box-sizing: border-box;
    }

    /* Add a gray background color with some padding */
    body {
    font-family: Arial;
    padding: 20px;
    background: #f1f1f1;
    }

    /* Header/Blog Title */
    .header {
    padding: 30px;
    font-size: 40px;
    text-align: center;
    background: white;
    }

    /* Create two unequal columns that floats next to each other */
    /* Left column */
    .leftcolumn {   
    float: left;
    width: 85%;
    }

    /* Right column */
    .rightcolumn {
    float: left;
    width: 15%;
    padding-left: 20px;
    }

    /* Fake image */
    .fakeimg {
    background-color: #aaa;
    width: 100%;
    padding: 20px;
    }

    /* Add a card effect for articles */
    .card {
    background-color: white;
    padding: 20px;
    margin-top: 20px;
    }

    /* Clear floats after the columns */
    .row:after {
    content: "";
    display: table;
    clear: both;
    }

    /* Footer */
    .footer {
    padding: 20px;
    text-align: center;
    background: #ddd;
    margin-top: 20px;
    }

    /* Responsive layout - when the screen is less than 800px wide, make the two columns stack on top of each other instead of next to each other */
    @media screen and (max-width: 800px) {
    .leftcolumn, .rightcolumn {   
        width: 100%;
        padding: 0;
    }
    }
    </style>
    </head>

    <body>

        <div class="header">
        <h2>Stocksy's Cloud Blog</h2>
        </div>

        <div class="row">
        
        <div class="leftcolumn">
            <div class="card">
                <h2>JULY 2025</h2>
                <h3>Site now uses IAM Roles & OIDC to run GitHub Actions &#128640</h3>
                <p>
                    In the previous blog (Future Improvements section), I recognised that a security issue existed within my website implementation. Long-lived credentials, in the form of access keys and secret access keys were attached to IAM users. 
                    These creds were used to handle calls to STS (AWS Security Token Service). STS generated and passed short-lived access tokens to GitHub Actions, which in turn were used by GitHub Actions workflows to use AWS services every time the workflow was triggered.
                    I was happy that the IAM policies I had written earlier were good for reuse, as they allow access only to services required by the GitHub Actions workflows (least-privileged principle). 
                    What was not security best-practice was attaching the IAM policies to IAM users as inline policies, when using Roles is AWS recommended practice.
                    Not using Roles was however, only the minor part of the problem. The main crux of the matter is the long-lived access keys. 
                    Even though the keys were encrypted as GitHub Actions Secrets and accessed within the workflow code using environment variables, the keys, if leaked, could provide a long-term access method into my AWS account. For this reason, they had to go!
                    Here, I will dive into the details of the conversion to using Roles with OIDC (OpenID Connect) and some GitHub-related growing pains.
                </p>
                <h4>Research &#128214</h4>
                <p>
                    As a starting assumption, I thought I'd need to setup an IdP (Identity Provider) using a service such as <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-identity.html" target="_blank">Cognito Identity Pools</a>. 
                    This is untrue: Although it performs a service to generate temporary AWS credentials, Cognito Identity Pools is aimed more at issuing human users with temporary access credentials, where the call <i>sts:AssumeRoleWithWebIdentity</i> is used in concert with a WebID Provider such as a social network login.
                    I did some digging into what I'd need to authenticate GitHub Actions with AWS and came across this <a href="https://aws.amazon.com/blogs/security/use-iam-roles-to-connect-github-actions-to-actions-in-aws/" target="_blank">AWS Security Blog by David Rowe</a>, which got me started. I also owe a shout to this useful <a href="https://www.youtube.com/watch?v=Hc_jrDpLMg8" target="_blank">four-part video by Siba N.</a> which explains much the same use case.
                </p>
                <h4>Getting Going &#127939</h4>
                <p>    
                    I quickly realised two things:
                    <ul>
                        <li>I didn't need to create/run an Identity Pool. All I needed on the AWS side was to create an IAM Identity Provider, add a few GitHub details provided in the blog, and attach it to a Role. The GitHub details are used to establish a Trust Relationship, embedded within the IAM Role, to the OIDC Provider. Great!</li>
                        <li>Although not overly stressed in the blog, I would need to create a GitHub Organization, something I hadn't needed to date. All my repos were previously stored in a personal account, but use of an Organization is a mandated field within the IAM Identity Provider options.
                            The Organization had to be created and my repos transferred into it. This proved to be a little painful and took me a couple of hours, because my existing GitHub PAT (Personal Access Token) refused to co-operate with the Organization, leading me to generate a replacement PAT and associate it with the Organization, which once again allowed me to pull/push code from/to the repos within the new Org.</li>
                    </ul>
                    The below image shows the Trust Relationship within one of the Role, used for the python-backend code repo (AWS Account ID and GitHub Organization & Repo are obfuscated):
                </p>

                <img src="../assets/trust_relationship.png" alt="AWS Trust Relationship image" width="800" height="500">

            </div>
                <p>
                    <object
                        data="../assets/website_architecture.pdf"
                        type="application/pdf"
                        width="100%"
                        height="1000"
                        title="Website Architecture PDF"
                    >
                        <iframe
                            src="../assets/website_architecture.pdf"
                            width="150%"
                            height="150%"
                            style="border: none"
                            title="Fallback PDF Viewer"
                        >
                            <p>
                                Your browser does not support PDFs.
                                [<a href="../assets/website_architecture.pdf" target="_blank">Download the PDF</a>]
                            </p>
                        </iframe>
                    </object>
                </p>
            </div>

        <div class="rightcolumn">
            <div class="card">
                <h3>Previous Blogs</h3>
                <p>
                    <a href="/blog/blog_202505.html">May 2025</a>
                </p>
            </div>
        </div>

        <div class="footer">
            <h2>
                <a href="../">Home</a>
            </h2>
        </div>

        <!-- Hit counter, written by Claude AI -->
        <div id="hitCounter">Hit Counter: Loading...</div>
        
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                try {
                    const counter = document.getElementById('hitCounter');
                    if (!counter) return; // Exit if element not found
                    
                    // Get the page path to use as a unique identifier
                    const pagePath = window.location.pathname;

                    // API_ENDPOINT env var will be replaced during build time
                    const apiEndpoint = '%%API_ENDPOINT%%/incrementCounter';

                    // Call the API Gateway endpoint to increment the counter
                    fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ pagePath: pagePath })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Update the counter with the value from the DB
                        counter.textContent = 'Hit Counter: ' + data.count;
                    })
                    .catch(error => {
                        console.error('Error updating hit counter:', error);
                        counter.textContent = 'Hit Counter: Error';
                    });
                } catch (error) {
                    console.log('Hit counter error:', error);
                }
            });
        </script>

    </body>
</html>
