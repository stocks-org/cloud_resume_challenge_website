<!DOCTYPE html>
<html>
    <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    * {
    box-sizing: border-box;
    }

    /* Add a gray background color with some padding */
    body {
    font-family: Arial;
    padding: 20px;
    background: #f1f1f1;
    }

    /* Header/Blog Title */
    .header {
    padding: 30px;
    font-size: 40px;
    text-align: center;
    background: white;
    }

    /* Create two unequal columns that floats next to each other */
    /* Left column */
    .leftcolumn {   
    float: left;
    width: 85%;
    }

    /* Right column */
    .rightcolumn {
    float: left;
    width: 15%;
    padding-left: 20px;
    }

    /* Fake image */
    .fakeimg {
    background-color: #aaa;
    width: 100%;
    padding: 20px;
    }

    /* Add a card effect for articles */
    .card {
    background-color: white;
    padding: 20px;
    margin-top: 20px;
    }

    /* Clear floats after the columns */
    .row:after {
    content: "";
    display: table;
    clear: both;
    }

    /* Footer */
    .footer {
    padding: 20px;
    text-align: center;
    background: #ddd;
    margin-top: 20px;
    }

    /* Responsive layout - when the screen is less than 800px wide, make the two columns stack on top of each other instead of next to each other */
    @media screen and (max-width: 800px) {
    .leftcolumn, .rightcolumn {   
        width: 100%;
        padding: 0;
    }
    }
    </style>
    </head>

    <body>

        <div class="header">
        <h2>Stocksy's Cloud Blog</h2>
        <h4>July 2025</h4>
        </div>

        <div class="row">

            <div class="leftcolumn">
                <div class="card">

                    <h2>StocksCloud Website's GitHub Actions now use an OIDC and IAM Roles to improve security &#128640</h2>

                    <p>
                        In the previous blog (Future Improvements section), I recognised that a security issue existed within the StocksCloud website implementation. Long-lived credentials, in the form of access keys and secret access keys, were attached to IAM Users. 
                        When a workflow was triggered, the creds were used to call AWS STS (Security Token Service). STS generated and passed short-lived access tokens to GitHub Actions, which in turn were used by GitHub Actions workflows to use AWS services.
                        I was happy that the IAM policies I had written earlier were good for reuse, because they allow access to only the services required by GitHub Actions workflows (principle of least privilege). 
                        What was not security best-practice was attaching these IAM policies to IAM users as Inline policies (directly attached). Using roles (with policies attached to the Role) is AWS recommended practice. 
                        Not creating and using roles was however only the minor part of the problem. The main crux of the matter is the long-lived access keys. 
                        Even though the keys were encrypted in GitHub Actions Secrets and accessed within the workflow using environment variables, the keys, if leaked, could provide a long-term access method into my AWS account. For this reason, they had to go! 
                        Here, I will dive into the details of the conversion to using AWS Roles with OIDC (OpenID Connect) and some GitHub-related growing pains.
                    </p>

                    <h4>Research &#128214</h4>
                    <p>
                        As a starting assumption, I thought I'd need to setup an IdP (Identity Provider) using a service such as <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-identity.html" target="_blank">Cognito Identity Pools</a>. 
                        This is untrue: Although it does perform a service to generate temporary credentials via STS, Cognito Identity Pools is aimed more at issuing human users with temporary access credentials, where the call <i>sts:AssumeRoleWithWebIdentity</i> is used alongside a WebID Provider such as a social network login.
                        I did some digging into what I'd need to authenticate GitHub Actions with AWS and came across a <a href="https://aws.amazon.com/blogs/security/use-iam-roles-to-connect-github-actions-to-actions-in-aws/" target="_blank">AWS Security Blog by David Rowe</a>, which got me started. A further <a href="https://docs.github.com/en/actions/how-tos/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services" target="_blank">GitHub Doc</a> explains the OIDC concept from GitHub's perspective. 
                        I also owe a shout to this useful <a href="https://www.youtube.com/watch?v=Hc_jrDpLMg8" target="_blank">four-part video by Siba N.</a> which explains much the same use case.
                    </p>

                    <h4>Getting Started &#127939</h4>
                    <p>    
                        I quickly realised two things:
                        <ul>
                            <li>As above, I didn't need to create an Identity Pool. All I needed on the AWS side was to create an IAM Identity Provider, add a few GitHub details provided in the AWS Security blog, and attach it to a Role. The GitHub details are used to create a Trust Relationship, embedded within the Role, between AWS and the OIDC Provider. I also attached my prepared IAM policies to the Roles (one policy per Role, one Role for each repo). Great news!</li>
                            <li>Not so easy! Although it's not overly stressed in the blog, I needed to create a GitHub Organization, something I hadn't needed to date. All my repos were previously stored in a personal account, but use of an Organization is a mandated field within the IAM Identity Provider options.
                                The Organization had to be created and my repos transferred into it. This proved to be a little painful and took me a couple of hours, because my existing GitHub PAT (Personal Access Token) refused to co-operate with the new Organization, leading me to generate a replacement PAT and associate it with the new Organization. This once again allowed me to pull/push code from/to the website & backend repos which now reside within the Organization.</li>
                        </ul>
                    </p>
                    <p>
                        <i>Fig 1: Shows the Trust Relationship established within the Role and the OIDC Provider, for the cloud_resume_challenge_website repo.</i> (Obfuscated items: AWS Account ID, GitHub Organization name).
                    </p>
                    <img src="../assets/trust_relationship.png" alt="AWS Trust Relationship image" width="75%" height="75%" class="center">

                    <h4>&#9995 STOP using Access Keys stored as GitHub Secrets and START using role-to-assume &#128274</h4>
                    
                    <p>
                        This is probably best explained by showing the old and new GitHub Actions workflow output as a comparison. In the old workflow, the GitHub Secrets named 'aws-access-key-id' and 'aws-secret-access-key' are accessed in the step named 'Configure AWS Credentials'. This uses the workflow 'aws-actions/configure-aws-credentials@v3'.
                        Although the secret values are not exposed in code or the workflow output, they were long-lived access keys which existed within a user of my AWS account, meaning they could potentially be leaked.
                    </p>
                    <p>
                        <i>Fig 2: The old GitHub Actions workflow, using an Access Key and Secret Access Key with an IAM User & Inline Policy to authenticate and use AWS services.</i>
                    </p>
                    <img src="../assets/cloud_resume_challenge_website_old_workflow.png" alt="GitHub Actions old workflow showing Secrets being used" width="100%" height="100%" class="center">
                    
                    <p>
                        The change to using a Role and OIDC Provider is shown in the updated workflow below. It replaces the GitHub secrets with 'role-to-assume' and 'role-session-name', using workflow 'aws-actions/configure-aws-credentials@v4' (as a side note, I bumped to using v4 rather than v3 as part of updating the workflow file).
                    </p>
                    <p>    
                        New workflow key/values:
                        <ul>
                            <li><b>role-to-assume:</b> this contains the all-important ARN value of the Role to be assumed. This value is the ARN of the role being assumed by the GitHub OIDC Provider.</li>
                            <li><b>role-session-name:</b> This is not as important. I queried <a href="//claude.ai/" target="_blank">Claude AI</a> about the significance of it, who advised it should be a descriptive value and as best practice should reference the github.run_id, injected as an environment variable. This can be used as an aid to track GitHub Actions workflow runs across log files.</li>
                        </ul>
                    </p>
                    <p>
                        <i>Fig 3: The new GitHub Actions workflow applies a role-to-assume ARN which allows the OIDC assumed role to authenticate and use AWS services. Note the ARN in Fig 1 above - this is the ARN of the AWS Role & Trust Relationship which allows trust to be established with the GitHub OIDC Provider.</i> (Obfuscated items: AWS Account ID, assumedRoleId).
                    </p>
                    <img src="../assets/cloud_resume_challenge_website_new_workflow.png" alt="GitHub Actions new workflow showing assumedRoleId being used" width="100%" height="100%" class="center">

                    <p>
                        Since taking the new workflow screenshot, I've added the role-to-assume value as a GitHub Actions Secret, called using an environment variable <b>role-to-assume: ${{ secrets.AWS_IAM_ROLE }}</b>. This removes my AWS Account ID from the workflow codebase and output, further improving account security.
                    </p>

                    <h4>Conclusion &#x1F9EA</h4>
                    <p>
                        I previously identified an important security improvement to stop using long-lived access keys in my GitHub Actions automation workflows. This has now been realised: the access keys were made redundant and subsequently were deleted from both my AWS account and GitHub Actions Secrets. &#127881
                    </p>
                    <p>
                        Thank you for reading!
                    </p>
                </div>
            </div>

            <div class="rightcolumn">
                <div class="card">
                    <h3>Other Blogs</h3>
                    <p>
                        <a href="/blog/blog_202505.html">May 2025</a>
                    </p>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <h2>
                <a href="../">Home</a>
            </h2>
        </div>

        <!-- Hit counter, written by Claude AI -->
        <div id="hitCounter">Hit Counter: Loading...</div>
        
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                try {
                    const counter = document.getElementById('hitCounter');
                    if (!counter) return; // Exit if element not found
                    
                    // Get the page path to use as a unique identifier
                    const pagePath = window.location.pathname;

                    // API_ENDPOINT env var will be replaced during build time
                    const apiEndpoint = '%%API_ENDPOINT%%/incrementCounter';

                    // Call the API Gateway endpoint to increment the counter
                    fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ pagePath: pagePath })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Update the counter with the value from the DB
                        counter.textContent = 'Hit Counter: ' + data.count;
                    })
                    .catch(error => {
                        console.error('Error updating hit counter:', error);
                        counter.textContent = 'Hit Counter: Error';
                    });
                } catch (error) {
                    console.log('Hit counter error:', error);
                }
            });
        </script>

    </body>
</html>
