<!DOCTYPE html>
<html>
    <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    * {
    box-sizing: border-box;
    }

    /* Add a gray background color with some padding */
    body {
    font-family: Arial;
    padding: 20px;
    background: #f1f1f1;
    }

    /* Header/Blog Title */
    .header {
    padding: 30px;
    font-size: 40px;
    text-align: center;
    background: white;
    }

    /* Create two unequal columns that floats next to each other */
    /* Left column */
    .leftcolumn {   
    float: left;
    width: 85%;
    }

    /* Right column */
    .rightcolumn {
    float: left;
    width: 15%;
    padding-left: 20px;
    }

    /* Fake image */
    .fakeimg {
    background-color: #aaa;
    width: 100%;
    padding: 20px;
    }

    /* Add a card effect for articles */
    .card {
    background-color: white;
    padding: 20px;
    margin-top: 20px;
    }

    /* Clear floats after the columns */
    .row:after {
    content: "";
    display: table;
    clear: both;
    }

    /* Footer */
    .footer {
    padding: 20px;
    text-align: center;
    background: #ddd;
    margin-top: 20px;
    }

    /* Responsive layout - when the screen is less than 800px wide, make the two columns stack on top of each other instead of next to each other */
    @media screen and (max-width: 800px) {
    .leftcolumn, .rightcolumn {   
        width: 100%;
        padding: 0;
    }
    }
    </style>
    </head>

    <body>

        <div class="header">
        <h2>Stocksy's Cloud Blog</h2>
        <h4>July 2025</h4>
        </div>

        <div class="row">
            
            <div class="leftcolumn">
                <div class="card">

                    <h2>Site now uses IAM Roles & OIDC to run GitHub Actions &#128640</h2>

                    <p>
                        In the previous blog (Future Improvements section), I recognised that a security issue existed within my website implementation. Long-lived credentials, in the form of access keys and secret access keys were attached to IAM users. 
                        These creds were used to handle calls to STS (AWS Security Token Service). STS generated and passed short-lived access tokens to GitHub Actions, which in turn were used by GitHub Actions workflows to use AWS services every time the workflow was triggered.
                        I was happy that the IAM policies I had written earlier were good for reuse, as they allow access only to services required by the GitHub Actions workflows (least-privileged principle). 
                        What was not security best-practice was attaching the IAM policies to IAM users as inline policies, when using Roles is AWS recommended practice.
                        Not using Roles was however, only the minor part of the problem. The main crux of the matter is the long-lived access keys. 
                        Even though the keys were encrypted as GitHub Actions Secrets and accessed within the workflow code using environment variables, the keys, if leaked, could provide a long-term access method into my AWS account. For this reason, they had to go!
                        Here, I will dive into the details of the conversion to using AWS Roles with OIDC (OpenID Connect) and some GitHub-related growing pains.
                    </p>

                    <h4>Research &#128214</h4>
                    <p>
                        As a starting assumption, I thought I'd need to setup an IdP (Identity Provider) using a service such as <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-identity.html" target="_blank">Cognito Identity Pools</a>. 
                        This is untrue: Although it performs a service to generate temporary AWS credentials, Cognito Identity Pools is aimed more at issuing human users with temporary access credentials, where the call <i>sts:AssumeRoleWithWebIdentity</i> is used in concert with a WebID Provider such as a social network login.
                        I did some digging into what I'd need to authenticate GitHub Actions with AWS and came across this <a href="https://aws.amazon.com/blogs/security/use-iam-roles-to-connect-github-actions-to-actions-in-aws/" target="_blank">AWS Security Blog by David Rowe</a>, which got me started. A further <a href="https://docs.github.com/en/actions/how-tos/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services" target="_blank">GitHub Doc</a> explains the OIDC concept from GitHub's perspective. 
                        I also owe a shout to this useful <a href="https://www.youtube.com/watch?v=Hc_jrDpLMg8" target="_blank">four-part video by Siba N.</a> which explains much the same use case.
                    </p>

                    <h4>Getting Started &#127939</h4>
                    <p>    
                        I quickly realised two things:
                        <ul>
                            <li>As above, I didn't need to create/run an Identity Pool. All I needed on the AWS side was to create an IAM Identity Provider, add a few GitHub details provided in the blog, and attach it to a Role. The GitHub details are used to establish a Trust Relationship, embedded within the IAM Role, to the OIDC Provider. Great!</li>
                            <li>Although not overly stressed in the blog, I would need to create a GitHub Organization, something I hadn't needed to date. All my repos were previously stored in a personal account, but use of an Organization is a mandated field within the IAM Identity Provider options.
                                The Organization had to be created and my repos transferred into it. This proved to be a little painful and took me a couple of hours, because my existing GitHub PAT (Personal Access Token) refused to co-operate with the new Organization, leading me to generate a replacement PAT and associate it with the Organization. This once again allowed me to pull/push code from/to the website & backend repos, which now reside within the Organization.</li>
                        </ul>
                    </p>
                    <p>
                        <i>Fig 1: Shows the Trust Relationship established within the Role and the OIDC provider, for the cloud_resume_challenge_website repo.</i> (Obfuscated items: AWS Account ID, GitHub Organization name).
                    </p>
                    <img src="../assets/trust_relationship.png" alt="AWS Trust Relationship image" width="75%" height="75%" class="center">

                    <h4>&#9995 STOP using Access Keys stored as GitHub Secrets and START using role-to-assume &#128274</h4>
                    
                    <p>
                        This is probably best explained by showing the old and new GitHub Actions output as a comparison. In the old workflow, the aws-access-key-id and aws-secret-access-key GitHub Secrets are accessed in the step named "Configure AWS Credentials". This uses the workflow 'aws-actions/configure-aws-credentials@v3'.
                        Although the secret values are not exposed in code or in the workflow output, they were long-lived access keys which existed under a User in my AWS account, meaning they could potentially be leaked.
                    </p>
                    <p>
                        <i>Fig 2: Shows the GitHub Actions workflow as it used to be, using the Access Key and Secret Access Key to authenticate and use AWS services.</i>
                    </p>
                    <img src="../assets/cloud_resume_challenge_website_old_workflow.png" alt="GitHub Actions old workflow showing Secrets being used" width="100%" height="100%" class="center">
                    
                    <p>
                        The update to using OIDC tokens is shown below in the new workflow file below. It replaces the GitHub secrets with role-to-assume and role-session-name, using workflow 'aws-actions/configure-aws-credentials@v4' (I bumped to using v4 rather than v3 as part of rewriting the workflow).
                    </p>
                    <p>    
                        New workflow key/values:
                        <ul>
                            <li>role-to-assume: this contains the all-important ARN value of the Role to be assumed. See Fig 1 and note the ARN values matches the ARN of the role for <b>GitHubActions_cloud_resume_challenge_website</b>. This is the role being assumed by the GitHub OIDC.</li>
                            <li>role-session-name: This is not as important. I queried <a href="//claude.ai/" target="_blank">Claude AI</a> about the significance of it, who advised it should be descriptive and as best practice reference the GitHub workflow ID, so it uses an environment variable to achieve this. The Workflow ID helps to track GitHub Actions workflow runs across associated logfiles.</li>
                        </ul>
                    </p>
                    <p>
                        <i>Fig 3: The GitHub Actions workflow as it is now, using role-to-assume ARN which allows the OIDC assume role to authenticate and use AWS services. Note the ARN matches the ARN in Fig 1 - this is the AWS Role & Trust Relationship being used by the GitHub OIDC.</i> (Obfuscated items: AWS Account ID, assumedRoleId).
                    </p>
                    <img src="../assets/cloud_resume_challenge_website_new_workflow.png" alt="GitHub Actions new workflow showing assumedRoleId being used" width="100%" height="100%" class="center">

                    <h4>Conclusion &#x1F9EA</h4>
                    <p>
                        It was an important security posture improvement to cease using access keys in my GitHub Actions automation pipelines. This has been achieved: the keys are now redundant and have been deleted from my AWS account &#129395
                    </p>

                </div>
            </div>

            <div class="rightcolumn">
                <div class="card">
                    <h3>Other Blogs</h3>
                    <p>
                        <a href="/blog/blog_202505.html">May 2025</a>
                    </p>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <h2>
                <a href="../">Home</a>
            </h2>
        </div>

        <!-- Hit counter, written by Claude AI -->
        <div id="hitCounter">Hit Counter: Loading...</div>
        
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                try {
                    const counter = document.getElementById('hitCounter');
                    if (!counter) return; // Exit if element not found
                    
                    // Get the page path to use as a unique identifier
                    const pagePath = window.location.pathname;

                    // API_ENDPOINT env var will be replaced during build time
                    const apiEndpoint = '%%API_ENDPOINT%%/incrementCounter';

                    // Call the API Gateway endpoint to increment the counter
                    fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ pagePath: pagePath })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Update the counter with the value from the DB
                        counter.textContent = 'Hit Counter: ' + data.count;
                    })
                    .catch(error => {
                        console.error('Error updating hit counter:', error);
                        counter.textContent = 'Hit Counter: Error';
                    });
                } catch (error) {
                    console.log('Hit counter error:', error);
                }
            });
        </script>

    </body>
</html>
